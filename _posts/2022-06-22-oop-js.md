---
layout: post
title: The Hitchhiker's Guide to OOP in Javascript
subtitle: Lean OOP programming concepts and patterns in Javascript
cover-img: /assets/img/cover.jfif
thumbnail-img: /assets/img/t-sql.jpg
share-img: /assets/img/path.jpg
tags: [js, oop]
---

## Table of Contents

## OOP

topics from [javscript oop course, and js oop book] ==> turn into series of blog articles

Objects:
-Object literals
-Factories
-constructors
-Constructor property
-functions are objects
-Value vs refernce types
-Adding or removing properties
-Enumerating proprties
-Abstraction
-Private Properties and methods
-Getters and setters
-Task: Stop watch

prototypes:
-inheritance
-Prototypes and prototypical inheritance
-Mutli level inheritance
-Property Descriptor
-Constructor Prototypes
-Prototypes v instance members
-iterating instance and Prototypes
-Avoid Extending the built-in object methods
Task:

prototypcial inheritance:
creating your own prototypical inheritance
-Resetting the constructor
-calling the super constructor
-intermediate function inheritance
-Methods Overriding
-Polymorphism
-when to use inheritance
-Mixins
Exerecise:
ES6 classes:

Es6 modules

Book:
1-Primitive vs refernce types
2-functions
3-understanding objects
4-constructor and prototypes
5-inheritance
6-Object patterns

Resources:

-V8 internals

-Exectution context and Scope chain

-Asynchonisty in Js

Event Queue and call stack

Resources :

## Classes

```js
class Circle {
  constructor(radius) {
    this.radius = radius;
    this.move = function () {
      //code
      //here are not on the prototype, instead they are on the own properties
    };
  }
  //Instance method
  draw() { 
    //code
    //methods are on the prototype
  }
  //Static method
  static parse(str){
      const radius = JSON.parse(str).radius;
      return new Circle(radius);
  }
}


//Class Declaration 
class Circle {

}
//unlike functions, class [Declarations, Expressions] are not hoisted
//Class Expression
const Square = class {

}

const circle = new Circle.parse('{"radius: 1"}');
console.log(circle);



class Circle {
  constructor(radius){
    this.radius = radius;
    this.move = function(){
      console.log('move')
    }
  }

    draw(){
      console.log('draw');
    }
  static parse(str){
    const radius = JSON.parse(str).radius;
    return new Circle(radius);
  }
  
}
const c1 = new Circle();
c1.draw();
c1.move();
console.log(c1);
console.log(typeof Circle);
const c2 = Circle.parse('{"radius": 1}');
console.log(c2)


//this 
const Square = function(){
  this.draw = function(){
    console.log(this);
  }
}
const sq = new Square();
//notice this behaviour 
//Method call
sq.draw();
//notice also this behaviour 
const draw = sq.draw;
//function call, here 'this' will point to the global object 
//so it ppreferable to use 'use strict' mode to make sure that 'this' will return undefined instead of invoking to the global window
//draw(); //window object 


//by Default, the body of class is excuting on 'strict' mode, to prevent you from modifying the global this accidently 


//private memebers using Symbol


function random(){
  return Math.random().toString(36).slice(-5)
}
const name = 'yousef';
const obj = {
  name,
  [random()]: true
}

console.log(obj);
console.log('----------------------');
const _radius = Symbol();
const _draw = Symbol();
console.log(_radius);
class Triangle {
  constructor(radius){
    this[_radius] = radius;
  }
  [_draw](){
    return 3;
  }
}
const tr = new Triangle(2);
console.log(tr)
console.log(tr._radius);
const key = Object.getOwnPropertySymbols(tr);
console.log(tr[key[0]]);
console.log(key);
console.log('-------------------------------');
//Full private members using WeakMap()

const _diameter = new WeakMap();
const _move = new WeakMap();
const privateProps = new WeakMap();
class Hexa{
  constructor(radius){
    _diameter.set(this, radius);
    //this._diameter = radius ==> under the hood
    // _move.set(this, function(){
    //   console.log('move');
    //   console.log(this); //undefined
    // })
    _move.set(this, _ => {console.log(this)}); //object instance
    //we can define multiple properties instead of individually define it 
    privateProps.set(this, {
      radius: radius,
      start: _ => {
        console.log('starting....');
      }
    });
    //to access 
    privateProp.get(this).radius;
    provateProp.get(this).start()
  }
  
  draw(){
    console.log(_diameter.get(this)); //=> will return the value of this property
    _move.get(this)()
  }
}
const hex = new Hexa(2);
console.log(hex.draw());


//Getters and Setters: in ES6 instead of doing Object.defineProperty(this, 'prop', {get: function(){}}) and so on, we have the set and get keyword that so the same functionalit but simpler , I am gonna copy the code above and try to implement the setter and getter

class Sphinex{
  constructor(radius){
    _diameter.set(this, radius);
    //this._diameter = radius ==> under the hood
    // _move.set(this, function(){
    //   console.log('move');
    //   console.log(this); //undefined
    // })
    _move.set(this, _ => {console.log(this)}); //object instance
    //we can define multiple properties instead of individually define it 
    privateProps.set(this, {
      radius: radius,
      start: _ => {
        console.log('starting....');
      }
    });
    //to access 
    privateProp.get(this).radius;
    provateProp.get(this).start()
  }
  //I am gonna comment out draw that give us access to private properties, and implement get
  /*draw(){
    console.log(_diameter.get(this)); //=> will return the value of this property
    _move.get(this)()
  }*/
  get radius(){
    return _diameter.get(this);
  }
  set radius(value){
    if(value <= 0) throw new Error('invalid radius');
    _diameter.set(this, value);
  }
}
const sp = new Sphinex(2);
console.log(sp.draw());



console.log('-------------------Inheritance------------------');

class Shape{
  constructor(color){
    this.color = color;
  }
  move(){
    console.log('move')
  }
}

class Circle extends Shape{
  constructor(color, radius){
    super(color);
    this.radius = radius;
  }
  draw(){
    console.log('draw');
  }
}

console.log('-------------------Method Overriding------------');
class Shape{
  constructor(color){
    this.color = color;
  }
  move(){
    console.log('move')
  }
}

class Circle extends Shape{
  constructor(color, radius){
    super(color);
    this.radius = radius;
  }
  draw(){
    console.log('draw');
  }
  move(){
    super.move();
    console.log('move circle')
  }
}


```

## Constructor and Prototype

```js
/* Beginning of chapter 4: constructors and prototypes */
function Person(){
    
}
let person1 = new Person;
//you can check the type of an instance using the constructor property, 
//Every object instance is automatically created with constructor property that contains a reference to the constructor function created it
//for generic object(objects created by literal form or Object constructor), the constructor property is set to Object
//for objects created with custom constructor, a construcor prop points back to the constructor function createed it 

console.log(person1.constructor === Person); //true
let person2 = {
    name: 'yousef', 
    age: 21
}
console.log(person2.constructor);
function Person(name){
  // this.name = name;
  // this.sayName = function(){
  //   console.log(this.name);
  // }
  Object.defineProperty(this, "name", {
    get: function(){
      return name;
    },
    set: function(newName){
      name = newName;
    },
    enumerable: true,
    configurable: true
  });
  this.sayName = function(){
    console.log(this.name);
  }
}
let person = new Person('omar');
person.sayName();
console.log(person.constructor);
/*you are still advised to use instanceof to check the type of an
instance. This is because the constructor property can be overwritten and
therefore may not be completely accurate.*/

//what if we instantiate the object from a function constructor without a new keyword
let person3 = Person('meska');
console.log(person3 instanceof Person); //false
console.log(typeof person3); //undefined
console.log(name); //meska
/*the value of this
inside of the constructor is equal to the global this object. The variable
person1 doesn’t contain a value because the Person constructor relies on
new to supply a return value. Without new, Person is just a function without
a return statement. The assignment to this.name actually creates a global variable called name*/


/* Prototypes */
//contructor allow you to configure object instances with the same properties, but constructors alone doesn't eleminate code redundancy
/*In the example code thus far, each instance has had its own sayName()
method even though sayName() doesn’t change. That means if you have
100 instances of an object, then there are 100 copies of a function that
do the exact same thing, just with different data.
It would be much more efficient if all of the instances shared one
method, and then that method could use this.name to retrieve the appropriate
data. This is where prototypes come in.*/
//identifying the prototype property 
function hasPrototypeProperty(object, name){
  return name in object && !object.hasOwnProperty(name);
}

let person = {};
var prototype = Object.getPrototypeOf(person);
console.log(prototype == Object.prototype);

console.log(Object.prototype.isPrototypeOf(person));
//shadowing 
console.log(person.toString());
person.toString = function(){
  return '[object Custom]'
}
console.log(person.toString());
delete person.toString;
console.log(person.toString());
delete person.toString;

//using  prototypes with constructor
function Person(name){
  this.name = name;
}

Person.prototype.sayName = function(){
  console.log(`hello, ${this.name}`);
}
let person1 = new Person('yousef');
let person2 = new Person('meska');
person1.sayName();

//of course you can add any data type you want as a prototype property, but be carreful when you are dealing with reference type, because one instance can change another instance behaviour, like 
Person.prototype.fruits = []; //Array: reference type
person1.fruits.push('pizza');
console.log(person1.fruits); //['pizza'];
person2.fruits.push('apple');
console.log(person1.fruits); //[ 'pizza', 'apple' ]

//instead of adding one property after another on the prototype, it would be easier to add the properties as an object 
Person.prototype = {
  sayName: function(){
    console.log(this.name);
  },
  toString: function(){
    return `[Person ${this.name} ]`;
  }
}
//altought this code eleminate the need to type Person.prototype, however, there is one side effect to be aware of 
let person4 = new Person('Ali');
console.log(person4 instanceof Person); //true
console.log(person4.constructor === Person); //false
console.log(person4.constructor === Object); //true
//but, why?


//ths solution is to put the constructor inside the prototype 
Person.prototype = {
  constructor: Person,
  sayName: function(){
    ///
  }, 
  toString: function(){
    
  }
}
let person5 = new Person('osama');
console.log(person5.constructor == Person);


//Changing prototypes: 

var person6 = new Person("Nicholas");
var person7 = new Person("Greg");
Object.freeze(person6);
Person.prototype.sayHi = function() {
console.log("Hi");
};
person6.sayHi(); // outputs "Hi"
person7.sayHi(); // outputs "Hi"

//Built-in Object prototype:All built-in objects have constructors, and therefore, they have prototypes that you can change

Array.prototype.sum = function(){
  return this.reduce(function(prev, next){
    return prev + next;
  })
}
var number = [1,2,3,4,5];
var result = number.sum();
console.log(result);

String.prototype.capitalize = function(){
  return this.charAt(0).toUpperCase() + this.substring(1);
}
let name = 'yousef meska';
let resultt = name.capitalize();
console.log(resultt)



let person = {name: 'yousef'};
let objectBase = Object.getPrototypeOf(person);
let propertyDescriptor = Object.getOwnPropertyDescriptor(objectBase, "toString");


function Circle(){
  this.move = function(){
    this.draw(); //from the prototype
    console.log('move');
  }
}
Circle.prototype.draw = function(){
  console.log('draw');
}
let circle = new Circle();
circle.move(); //draw, move 

//Object.keys only return instance[own] members 
console.log(Object.keys(circle)); //move only

//for in loop returns all the instance[own] and prototype members 

//constructor resetting after prototypcial inheritance 

function Shape(color){
  this.color = color;
}
Shape.prototype.duplicate = function(){
  console.log('duplicate');
}
//Circle.prototype.constructor(1) === new Circle(1)
Circle.prototype = Object.create(Shape.prototype);
//Circle.prototype.constructor(1) === new Shape(1);
//the fix:
Circle.prototype.constructor = Circle;

//Calling the super constructor
function Circle(rdius){
  Shape.call(this, color);
  this.radius = radius;
}


//instead of manually do the prototypical inheritance every time we need to, we can make a function to automate this
//this is called intermediate function inhertia
function extend(Child, Parent){
  Child.prototype = Object.create(Parent.prototype);
  Child.prototype.constructor = Child;
}

function Square(){

}
extend(Square, Shape);

//Method overriding:

Circle.prototype.duplicate = function(){
  //calling the duplicate of Shape 
  Shape.prototype.duplicate.call(this);
  console.log('duplicate circle')
}


//Polymorphism: many form 
const shapes = [
  new Circle(),
  new Square()
];

for(let shape of shapes)
  shape.duplicate();



  //Mixinis 

  function mixin(target, ...sources){
    Object.assign(target, ...sources);
  }
  const canEat = {
    eat: function(){
      this.hunger--;
      console.log('eating')
    }
  };
  const canWalk = {
    walk: function(){
      console.log('walking')
    }
  };
  
  const canSwim = {
    swim: function(){
      console.log('swim');
    }
  }
  function Person (){

  }
//Object.assign(); //copy from object to object
//Object.assign({}, canEat, canWalk)
//Object.assign(Person.prototype, canEat, canWalk);
mixin(Person.prototype, canEat, canWalk);
const person = new Person();
console.log(person);
function Goldfish(){

}
//Object.assign(Goldfish.prototype, canEat, canSwim);
mixin.assign(Goldfish.prototype, canEat, canSwim);
const goldfish = new Goldfish();
console.log(goldfish);
```

## Inheritance

```js
//object inheritance
let book = {
  title: "The Javascript oop concepts",
};
//is the same as
var bookk = Object.create(Object.prototype, {
  title: {
    configurable: true,
    enumerable: true,
    value: "The Javascript oop concepts",
    writable: true,
  },
});

let person1 = {
  name: "yousef",
  sayName: function () {
    console.log(this.name);
  },
};
let person2 = Object.create(person1, {
  name: {
    configurable: true,
    enumerable: true,
    value: "ahmed",
    writable: true,
  },
});
person1.sayName();
person2.sayName();
console.log(person1.hasOwnProperty("sayName")); //true
console.log(person1.isPrototypeOf(person2)); //true
console.log(person2.hasOwnProperty("sayName")); //false

//create a prototypless object
let nakedObject = Object.create(null); //[[prototype]] = null

//Constructor inhertiance

//You write this
function YourConstructor() {
  //your code
}
//Javscript enginer does this for you behind the scenes
YourConstructor.prototype = Object.create(Object.prototype, {
  constructor: {
    configurable: true,
    enumerable: true,
    writable: true,
    value: YourConstructor,
  },
});
//meaning that any instance of YourConstrcuctor also inherit Object.prototype
//YourConstructor is 'subtype' of Object, and Object is 'supertype' of YourConstructor
/*Because the prototype property is writable, you can change the prototype
  chain by overwriting it. Consider the following example*/
function Rectangle(width, length) {
  this.width = width;
  this.length = length;
}
Rectangle.prototype.getArea = function () {
  return this.width * this.length;
};
function Square(size) {
  this.length = size;
  this.width = size;
}
Square.prototype = Rectangle.prototype; //or new Rectangle();
Square.prototype.constrcutor = Square;
let rect = new Rectangle(5, 6);
let square = new Square(6);
console.log(rect.getArea());
console.log(square.getArea());
console.log(rect instanceof Rectangle); // true
console.log(rect instanceof Object); // true
console.log(square instanceof Square); // true
console.log(square instanceof Rectangle); // true
console.log(square instanceof Object); // true

//we could simplify the code above using Object.create(), I will instantiate another constructor called Square1
function Square(size) {
  this.length = size;
  this.width = size;
}
Square.prototype = Object.create(Rectangle.prototype, {
  constructor: {
    configurable: true,
    enumerable: true,
    writable: true,
    value: Square,
  },
});

/*Always make sure that you overwrite the prototype before adding properties to it,
  or you will lose the added methods when the overwrite happens.*/

//abstraction: hide the details and expose only the essentials
function Circle(radius) {
  this.radius = radius;
  let defaultLocations = { x: 1, y: 2 };
  // this.getDefaultLocation = function(){
  //   return defaultLocations
  // } old way , the better approah is to use Object.defineProperties
  Object.defineProperty(this, "defaultLocation", {
    get: function () {
      return defaultLocations;
    },
    set: function (value) {
      if (!value.x || !value.y) {
        throw new Error("Invalid locations");
      }
      defaultLocations = value;
    },
  });

  /*this.computeOptimalLocation = function(){
      //some code here
      //here computerOptimalLocation is accessible from outside and we need to prevent this behaviour
      //the solution is to make it a function insde Circle, not a method of an instance, so we can't reach it from outside 

    };*/
  function computeOptimalLocation(factor) {
    //some code
  }
  this.draw = function () {
    //closure determine what variable will be accessbile from inner functions
    computeOptimalLocation(0.1);
    console.log("draw");
  };
}
const circle = new Circle(2);
circle.getDefaultLocation();

/*Constructor stealing:You simply call the supertype constructor
from the subtype constructor using either call() or apply() to
pass in the newly created object*/

function Rectangle(length, width) {
  this.length = length;
  this.width = width;
}
Rectangle.prototype.getArea = function () {
  return this.length * this.width;
};
function Square(size) {
  Rectangle.call(this, size, size);
}
Square.prototype = Object.create(Rectangle.prototype, {
  constructor: {
    writable: true,
    enumerable: true,
    configurable: true,
    value: Square,
  },
});
let square = new Square(6);
console.log(square.getArea());
//this approach called pseudoclassical inheritance

// but you cannot inherit own properties using prototypes.
// To inherit own properties correctly, you can use constructor stealing,
// which is simply calling a constructor function using call() or apply() so
// that any initialization is done on the subtype object
//Accessing SuperType methods
function Rectangle(length, width) {
  this.length = length;
  this.width = width;
}
Rectangle.prototype.getArea = function () {
  return this.length * this.width;
};

function Square(size) {
  Rectangle.call(this, size, size);
}
Square.protototype = Object.create(Rectangle.prototype, {
  constructor: {
    configurable: true,
    enumerable: true,
    writable: true,
    value: Square,
  },
});
//call the supertype method
Square.prototype.toString = function () {
  let text = Rectangle.prototype.toString.call(this);
  return text.replace("Rectangle", "Square");
};

```

## Object Patterns

```js
/* The module pattern: creational pattern designed to create singletion object with priviledged data,
Approach: is to use IIFE that returns an object
  priviledged methods: method that access privileged data
  You accomplish this by
creating closure functions as object methods
*/

let person = (function () {
  //private data variable
  let age = 25;
  return {
    //public methods and properties
    name: "yousef",
    getAge: function () {
      return age;
    },
    growOlder: function () {
      age++;
    },
  };
})();

console.log(person.name); // "Nicholas"
console.log(person.getAge()); // 25
person.age = 100;
console.log(person.getAge()); // 25
person.growOlder();
console.log(person.getAge()); // 26

/* revealing module pattern */
let guy = (function () {
  //private data variable
  let age = 25;

  //public methods and properties

  function getAge() {
    return age;
  }
  function growOlder() {
    age++;
  }

  return {
    name: "yousef",
    getAge: getAge,
    growOlder: growOlder,
  };
})();

//Private members for constructor:
function Person(name) {
  var age = 21;
  this.name = name;
  this.getAge = function () {
    return age;
  };
  this.growOlder = function () {
    age++;
  };
}

//---------------------------------
console.log('------making a varible shared across all the instances-----');

var Person = (function(){
  var age = 25;

  function InnerPerson(name){
    this.name = name;
  }
  InnerPerson.prototype.getAge = function(){
    return age;
  }
  InnerPerson.prototype.growOlder = function(){
    age++;
  }
  return InnerPerson;
}());

console.log('---------------');
//person is a singleton object
var pperson = (function(){
  var age = 25;
  
  return {
    getAge: function(){
      return age;
    },
    growAge: function(){
      age++;
    }
  }
}());

console.log(pperson.growAge());
console.log(pperson.getAge());

var Person = (function(){
  var age = 25;
  function InnerPerson(name){
    this.name = name;
  }
  InnerPerson.prototype = {
    getAge: function(){
      return age;
    },
    growAge: function(){
      age++;
    }
  }
  return InnerPerson;
              }())

var person1 = new Person();

//console.log(person1.age); //undefined
person1.getAge();
person1.growAge();
person1.getAge();
person1.growAge();
person1.growAge();
person1.getAge();
var person2 = new Person();
person2.getAge();


function PPerson(name){
  var age = 25;
  this.name = name;
  this.getAge = function(){
    return age;
  }
  this.growAge = function(){
    age++;
  }
}

var person3 = new PPerson();
person3.growAge();
person3.getAge();
var person4 = new PPerson();
person4.getAge();



console.log('----scope-safe constructor----');


function Person(name){
  if (this instanceof Person){
    this.name = name
  } else {
    return new Person(name);
  }
}
const person1 = new Person('yousef');
const person2 = new Person('ahmed');
console.log(person1 instanceof Person); //true
console.log(person2 instanceof Person); //false
```

## Mixins

```js
/* a simple example of a mixin
mixins are oftern used to extend an object functionalites while  avoiding the need of  inheritance 
function mixin(receiver, supplier){
    for(let prop in supplier){
        if(supplier.hasOwnProperty(prop)){
            receiver[prop] = supplier[prop];
        }
    }
}

let supplier = {
    name: 'yousef', 
    age: 21,
    getAge: function(){
        console.log(age);
    }
}
let receiver = {};
mixin(receiver, supplier);
console.log(receiver); */

//A detailed example to get the idea
function EventTarget() {}

EventTarget.prototype = {
  addListener: function (type, listener) {
    //create an array if doesn't exist
    if (!this.hasOwnProperty("_listeners")) {
      this._listeners = [];
    }
    if (typeof this._listeners[type] === "undefined") {
      this._listeners[type] = [];
    }
    this._listeners[type].push(listener);
  },
  fire: function (event) {
    if (!event.target) {
      event.target = this;
    }
    if (!event.type) {
      throw new Error('Event Object missing "type" property');
    }

    if (this._listeners && this._listeners[event.type] instanceof Array) {
      var listeners = this._listeners[event.type];
      for (let i = 0, len = listeners.length; i < len; i++) {
        listeners[i].call(this, event);
      }
    }
  },
  removeListeners: function (type, listener) {
    if (this._listeners && this._listeners[type] instanceof Array) {
      var listeners = this._listeners[type];
      for (let i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i] == listener) {
          listeners.splice(i, 1);
          break;
        }
      }
    }
  },
};

var target = new EventTarget();
target.addListener("message", function (event) {
  console.log("message is " + event.data);
});
target.addListener("age", function (event) {
  console.log("your age is " + event.data);
});
target.fire({
  type: "age",
  data: 21,
});
target.fire({
  type: "message",
  data: "hello world",
});

console.log(target);

//if you want to have a different type of object that also support EventTarget
//firt approach:
var person = new EventTarget();
person.name = "yousef";
person.sayName = function () {
  console.log(this.name);
  this.fire({ type: "namesaid", name: this.name });
};
//second alternative approach:
function Person(name) {
  this.name = name;
}
Person.prototype = Object.create(EventTarget.prototype, {
  constructor: Person,
  sayName: function () {
    console.log(this.name);
    this.fire({ type: "namesaid", name: this.name });
  },
});

const person = new Person();
console.log(person instanceof Person); //true
console.log(person instanceof EventTarget); //true

//third alternative and simpler approach: here there is no inheritance
function Person(name){

}
mixin(Person.prototype, new EventTarget());
mixin(Person.prototype, {
    constructor: Person, 
    sayName: function(){
        console.log(this.name);
        this.fire({type: "namesaid", name: this.name})
    }
})
let person = new Person('meska');
console.log(person instanceof Person); //true, 
console.log(person instanceof EventTarget); //false: //very important to know 

//fourth but related to third approach is to simplify the code above on just one single step 
//in this example a new EverntTarget instance is mixed with some new properties to create the person object without affecting the person' prototype chain 
//now person prototype is dierctly the Object()
let person = mixin(new EventTarget(), {
    name: 'meska',
    sayName: function(){
        console.log(this.name);
        this.fire({type: 'namesaid', name: this.name});
    }
})
console.log(person instanceof Object); //true
console.log(person instanceof EventTarget); //false


//look for this dangrous example
let person = mixin(new EventTarget, {
  get name(){
    return 'nicholas';
  },
  sayname: function(){
    console.log(this.name);
    this.fire({type: 'namesiad', name: name});
  }
});
console.log(person.name); //nicholas
person.name = 'yousef';
console.log(person.name); //yousef, see! a werid behaviour, name must not be changed 

//if you want an accessor property to be copied as an accessor property not a data property , you need a different mixin functionality 
function mixin(receiver, supplier){
  Object.keys(supplier).forEach(function(property){
    var descriptor = Object.getOwnPropertyDescriptor(supplier, property);
    Object.defineProperty(receiver, property, descriptor);
  });
  return receiver;
}
let person = mixin(new EventTarget, {
  get name(){
    return 'nicholas';
  },
  sayname: function(){
    console.log(this.name);
    this.fire({type: 'namesiad', name: name});
  }
});
console.log(person.name); //nicholas
person.name = 'yousef';
console.log(person.name); //nicholas 
```
