---
layout: post
title: Functional Programming in Javascript
subtitle: Lean Functional programming concepts and patterns in Javascript
cover-img: /assets/img/cover.jfif
thumbnail-img: /assets/img/t-sql.jpg
share-img: /assets/img/path.jpg
tags: [js, oop]
---


## Classes

```js
class Circle {
  constructor(radius) {
    this.radius = radius;
    this.move = function () {
      //code
      //here are not on the prototype, instead they are on the own properties
    };
  }
  //Instance method
  draw() { 
    //code
    //methods are on the prototype
  }
  //Static method
  static parse(str){
      const radius = JSON.parse(str).radius;
      return new Circle(radius);
  }
}


//Class Declaration 
class Circle {

}
//unlike functions, class [Declarations, Expressions] are not hoisted
//Class Expression
const Square = class {

}

const circle = new Circle.parse('{"radius: 1"}');
console.log(circle);



class Circle {
  constructor(radius){
    this.radius = radius;
    this.move = function(){
      console.log('move')
    }
  }

    draw(){
      console.log('draw');
    }
  static parse(str){
    const radius = JSON.parse(str).radius;
    return new Circle(radius);
  }
  
}
const c1 = new Circle();
c1.draw();
c1.move();
console.log(c1);
console.log(typeof Circle);
const c2 = Circle.parse('{"radius": 1}');
console.log(c2)


//this 
const Square = function(){
  this.draw = function(){
    console.log(this);
  }
}
const sq = new Square();
//notice this behaviour 
//Method call
sq.draw();
//notice also this behaviour 
const draw = sq.draw;
//function call, here 'this' will point to the global object 
//so it ppreferable to use 'use strict' mode to make sure that 'this' will return undefined instead of invoking to the global window
//draw(); //window object 


//by Default, the body of class is excuting on 'strict' mode, to prevent you from modifying the global this accidently 


//private memebers using Symbol


function random(){
  return Math.random().toString(36).slice(-5)
}
const name = 'yousef';
const obj = {
  name,
  [random()]: true
}

console.log(obj);
console.log('----------------------');
const _radius = Symbol();
const _draw = Symbol();
console.log(_radius);
class Triangle {
  constructor(radius){
    this[_radius] = radius;
  }
  [_draw](){
    return 3;
  }
}
const tr = new Triangle(2);
console.log(tr)
console.log(tr._radius);
const key = Object.getOwnPropertySymbols(tr);
console.log(tr[key[0]]);
console.log(key);
console.log('-------------------------------');
//Full private members using WeakMap()

const _diameter = new WeakMap();
const _move = new WeakMap();
const privateProps = new WeakMap();
class Hexa{
  constructor(radius){
    _diameter.set(this, radius);
    //this._diameter = radius ==> under the hood
    // _move.set(this, function(){
    //   console.log('move');
    //   console.log(this); //undefined
    // })
    _move.set(this, _ => {console.log(this)}); //object instance
    //we can define multiple properties instead of individually define it 
    privateProps.set(this, {
      radius: radius,
      start: _ => {
        console.log('starting....');
      }
    });
    //to access 
    privateProp.get(this).radius;
    provateProp.get(this).start()
  }
  
  draw(){
    console.log(_diameter.get(this)); //=> will return the value of this property
    _move.get(this)()
  }
}
const hex = new Hexa(2);
console.log(hex.draw());


//Getters and Setters: in ES6 instead of doing Object.defineProperty(this, 'prop', {get: function(){}}) and so on, we have the set and get keyword that so the same functionalit but simpler , I am gonna copy the code above and try to implement the setter and getter

class Sphinex{
  constructor(radius){
    _diameter.set(this, radius);
    //this._diameter = radius ==> under the hood
    // _move.set(this, function(){
    //   console.log('move');
    //   console.log(this); //undefined
    // })
    _move.set(this, _ => {console.log(this)}); //object instance
    //we can define multiple properties instead of individually define it 
    privateProps.set(this, {
      radius: radius,
      start: _ => {
        console.log('starting....');
      }
    });
    //to access 
    privateProp.get(this).radius;
    provateProp.get(this).start()
  }
  //I am gonna comment out draw that give us access to private properties, and implement get
  /*draw(){
    console.log(_diameter.get(this)); //=> will return the value of this property
    _move.get(this)()
  }*/
  get radius(){
    return _diameter.get(this);
  }
  set radius(value){
    if(value <= 0) throw new Error('invalid radius');
    _diameter.set(this, value);
  }
}
const sp = new Sphinex(2);
console.log(sp.draw());



console.log('-------------------Inheritance------------------');

class Shape{
  constructor(color){
    this.color = color;
  }
  move(){
    console.log('move')
  }
}

class Circle extends Shape{
  constructor(color, radius){
    super(color);
    this.radius = radius;
  }
  draw(){
    console.log('draw');
  }
}

console.log('-------------------Method Overriding------------');
class Shape{
  constructor(color){
    this.color = color;
  }
  move(){
    console.log('move')
  }
}

class Circle extends Shape{
  constructor(color, radius){
    super(color);
    this.radius = radius;
  }
  draw(){
    console.log('draw');
  }
  move(){
    super.move();
    console.log('move circle')
  }
}


```
